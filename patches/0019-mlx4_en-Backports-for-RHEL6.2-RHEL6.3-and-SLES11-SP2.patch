From 4c1b99148b5eeb1cdb2e251919a083b03aca35a4 Mon Sep 17 00:00:00 2001
From: Vladimir Sokolovsky <vlad@mellanox.com>
Date: Sun, 5 Aug 2012 22:00:42 +0300
Subject: [PATCH 19/21] mlx4_en: Backports for RHEL6.2 RHEL6.3 and SLES11 SP2

Signed-off-by: Vladimir Sokolovsky <vlad@mellanox.com>
---
 drivers/net/ethernet/mellanox/mlx4/en_ethtool.c |    4 ++
 drivers/net/ethernet/mellanox/mlx4/en_netdev.c  |   29 ++++++++++++
 drivers/net/ethernet/mellanox/mlx4/en_rx.c      |   56 +++++++++++++++++++++++
 drivers/net/ethernet/mellanox/mlx4/en_tx.c      |    4 ++
 4 files changed, 93 insertions(+), 0 deletions(-)

diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 72901ce..332e851 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@ -528,6 +528,7 @@ static void mlx4_en_get_ringparam(struct net_device *dev,
 	param->tx_pending = priv->tx_ring[0].size;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 static u32 mlx4_en_get_rxfh_indir_size(struct net_device *dev)
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
@@ -598,6 +599,7 @@ static int mlx4_en_set_rxfh_indir(struct net_device *dev,
 	mutex_unlock(&mdev->state_lock);
 	return err;
 }
+#endif
 
 static int mlx4_en_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
 			     u32 *rule_locs)
@@ -637,9 +639,11 @@ const struct ethtool_ops mlx4_en_ethtool_ops = {
 	.get_ringparam = mlx4_en_get_ringparam,
 	.set_ringparam = mlx4_en_set_ringparam,
 	.get_rxnfc = mlx4_en_get_rxnfc,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 	.get_rxfh_indir_size = mlx4_en_get_rxfh_indir_size,
 	.get_rxfh_indir = mlx4_en_get_rxfh_indir,
 	.set_rxfh_indir = mlx4_en_set_rxfh_indir,
+#endif
 };
 
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 073b85b..2a53952 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -45,6 +45,7 @@
 #include "mlx4_en.h"
 #include "en_port.h"
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 static int mlx4_en_setup_tc(struct net_device *dev, u8 up)
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
@@ -65,6 +66,7 @@ static int mlx4_en_setup_tc(struct net_device *dev, u8 up)
 
 	return 0;
 }
+#endif
 
 static int mlx4_en_vlan_rx_add_vid(struct net_device *dev, unsigned short vid)
 {
@@ -179,7 +181,11 @@ static void mlx4_en_clear_list(struct net_device *dev)
 static void mlx4_en_cache_mclist(struct net_device *dev)
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	struct netdev_hw_addr *ha;
+#else
+	struct dev_mc_list *mclist;
+#endif
 	char *mc_addrs;
 	int mc_addrs_cnt = netdev_mc_count(dev);
 	int i;
@@ -190,8 +196,13 @@ static void mlx4_en_cache_mclist(struct net_device *dev)
 		return;
 	}
 	i = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	netdev_for_each_mc_addr(ha, dev)
 		memcpy(mc_addrs + i++ * ETH_ALEN, ha->addr, ETH_ALEN);
+#else
+	netdev_for_each_mc_addr(mclist, dev)
+		memcpy(mc_addrs + i++ * ETH_ALEN, mclist->dmi_addr, ETH_ALEN);
+#endif
 	mlx4_en_clear_list(dev);
 	priv->mc_addrs = mc_addrs;
 	priv->mc_addrs_cnt = mc_addrs_cnt;
@@ -1044,6 +1055,7 @@ static int mlx4_en_change_mtu(struct net_device *dev, int new_mtu)
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 static int mlx4_en_set_features(struct net_device *netdev,
 		netdev_features_t features)
 {
@@ -1058,6 +1070,7 @@ static int mlx4_en_set_features(struct net_device *netdev,
 	return 0;
 
 }
+#endif
 
 static const struct net_device_ops mlx4_netdev_ops = {
 	.ndo_open		= mlx4_en_open,
@@ -1075,8 +1088,10 @@ static const struct net_device_ops mlx4_netdev_ops = {
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller	= mlx4_en_netpoll,
 #endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	.ndo_set_features	= mlx4_en_set_features,
 	.ndo_setup_tc		= mlx4_en_setup_tc,
+#endif
 };
 
 int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
@@ -1182,6 +1197,7 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	/*
 	 * Set driver features
 	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
 	if (mdev->LSO_support)
 		dev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;
@@ -1193,6 +1209,19 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 			NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX |
 			NETIF_F_HW_VLAN_FILTER;
 	dev->hw_features |= NETIF_F_LOOPBACK;
+#else
+	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+	if (mdev->LSO_support)
+		dev->features |= NETIF_F_TSO | NETIF_F_TSO6;
+
+	dev->vlan_features = dev->features;
+
+	dev->features |= NETIF_F_RXCSUM | NETIF_F_RXHASH;
+	dev->features |= NETIF_F_HIGHDMA |
+			NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX |
+			NETIF_F_HW_VLAN_FILTER;
+	dev->features |= NETIF_F_LOOPBACK;
+#endif
 
 	mdev->pndev[port] = dev;
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_rx.c b/drivers/net/ethernet/mellanox/mlx4/en_rx.c
index d49a7ac..ae1c6a9 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c
@@ -44,7 +44,11 @@
 
 static int mlx4_en_alloc_frag(struct mlx4_en_priv *priv,
 			      struct mlx4_en_rx_desc *rx_desc,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 			      struct page_frag *skb_frags,
+#else
+			      struct skb_frag_struct *skb_frags,
+#endif
 			      struct mlx4_en_rx_alloc *ring_alloc,
 			      int i)
 {
@@ -60,7 +64,11 @@ static int mlx4_en_alloc_frag(struct mlx4_en_priv *priv,
 			return -ENOMEM;
 
 		skb_frags[i].page = page_alloc->page;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 		skb_frags[i].offset = page_alloc->offset;
+#else
+		skb_frags[i].page_offset = page_alloc->offset;
+#endif
 		page_alloc->page = page;
 		page_alloc->offset = frag_info->frag_align;
 	} else {
@@ -68,11 +76,19 @@ static int mlx4_en_alloc_frag(struct mlx4_en_priv *priv,
 		get_page(page);
 
 		skb_frags[i].page = page;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 		skb_frags[i].offset = page_alloc->offset;
+#else
+		skb_frags[i].page_offset = page_alloc->offset;
+#endif
 		page_alloc->offset += frag_info->frag_stride;
 	}
 	dma = dma_map_single(priv->ddev, page_address(skb_frags[i].page) +
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 			     skb_frags[i].offset, frag_info->frag_size,
+#else
+			     skb_frags[i].page_offset, frag_info->frag_size,
+#endif
 			     PCI_DMA_FROMDEVICE);
 	rx_desc->data[i].addr = cpu_to_be64(dma);
 	return 0;
@@ -156,8 +172,13 @@ static int mlx4_en_prepare_rx_desc(struct mlx4_en_priv *priv,
 				   struct mlx4_en_rx_ring *ring, int index)
 {
 	struct mlx4_en_rx_desc *rx_desc = ring->buf + (index * ring->stride);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	struct page_frag *skb_frags = ring->rx_info +
 				      (index << priv->log_rx_info);
+#else
+	struct skb_frag_struct *skb_frags = ring->rx_info +
+					    (index << priv->log_rx_info);
+#endif
 	int i;
 
 	for (i = 0; i < priv->num_frags; i++)
@@ -185,7 +206,11 @@ static void mlx4_en_free_rx_desc(struct mlx4_en_priv *priv,
 				 struct mlx4_en_rx_ring *ring,
 				 int index)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	struct page_frag *skb_frags;
+#else
+	struct skb_frag_struct *skb_frags;
+#endif
 	struct mlx4_en_rx_desc *rx_desc = ring->buf + (index << ring->log_stride);
 	dma_addr_t dma;
 	int nr;
@@ -196,8 +221,13 @@ static void mlx4_en_free_rx_desc(struct mlx4_en_priv *priv,
 		dma = be64_to_cpu(rx_desc->data[nr].addr);
 
 		en_dbg(DRV, priv, "Unmapping buffer at dma:0x%llx\n", (u64) dma);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 		dma_unmap_single(priv->ddev, dma, skb_frags[nr].size,
 				 PCI_DMA_FROMDEVICE);
+#else
+		dma_unmap_single(priv->ddev, dma, skb_frag_size(&skb_frags[nr]),
+				 PCI_DMA_FROMDEVICE);
+#endif
 		put_page(skb_frags[nr].page);
 	}
 }
@@ -404,7 +434,11 @@ void mlx4_en_deactivate_rx_ring(struct mlx4_en_priv *priv,
 /* Unmap a completed descriptor and free unused pages */
 static int mlx4_en_complete_rx_desc(struct mlx4_en_priv *priv,
 				    struct mlx4_en_rx_desc *rx_desc,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 				    struct page_frag *skb_frags,
+#else
+				    struct skb_frag_struct *skb_frags,
+#endif
 				    struct sk_buff *skb,
 				    struct mlx4_en_rx_alloc *page_alloc,
 				    int length)
@@ -421,9 +455,15 @@ static int mlx4_en_complete_rx_desc(struct mlx4_en_priv *priv,
 			break;
 
 		/* Save page reference in skb */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 		__skb_frag_set_page(&skb_frags_rx[nr], skb_frags[nr].page);
 		skb_frag_size_set(&skb_frags_rx[nr], skb_frags[nr].size);
 		skb_frags_rx[nr].page_offset = skb_frags[nr].offset;
+#else
+		skb_frags_rx[nr].page = skb_frags[nr].page;
+		skb_frag_size_set(&skb_frags_rx[nr], skb_frag_size(&skb_frags[nr]));
+		skb_frags_rx[nr].page_offset = skb_frags[nr].page_offset;
+#endif
 		skb->truesize += frag_info->frag_stride;
 		dma = be64_to_cpu(rx_desc->data[nr].addr);
 
@@ -454,7 +494,11 @@ fail:
 
 static struct sk_buff *mlx4_en_rx_skb(struct mlx4_en_priv *priv,
 				      struct mlx4_en_rx_desc *rx_desc,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 				      struct page_frag *skb_frags,
+#else
+				      struct skb_frag_struct *skb_frags,
+#endif
 				      struct mlx4_en_rx_alloc *page_alloc,
 				      unsigned int length)
 {
@@ -473,7 +517,11 @@ static struct sk_buff *mlx4_en_rx_skb(struct mlx4_en_priv *priv,
 
 	/* Get pointer to first fragment so we could copy the headers into the
 	 * (linear part of the) skb */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	va = page_address(skb_frags[0].page) + skb_frags[0].offset;
+#else
+	va = page_address(skb_frags[0].page) + skb_frags[0].page_offset;
+#endif
 
 	if (length <= SMALL_PACKET_SIZE) {
 		/* We are copying all relevant data to the skb - temporarily
@@ -531,7 +579,11 @@ int mlx4_en_process_rx_cq(struct net_device *dev, struct mlx4_en_cq *cq, int bud
 	struct mlx4_en_priv *priv = netdev_priv(dev);
 	struct mlx4_cqe *cqe;
 	struct mlx4_en_rx_ring *ring = &priv->rx_ring[cq->ring];
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	struct page_frag *skb_frags;
+#else
+	struct skb_frag_struct *skb_frags;
+#endif
 	struct mlx4_en_rx_desc *rx_desc;
 	struct sk_buff *skb;
 	int index;
@@ -580,7 +632,11 @@ int mlx4_en_process_rx_cq(struct net_device *dev, struct mlx4_en_cq *cq, int bud
 		/* Get pointer to first fragment since we haven't skb yet and
 		 * cast it to ethhdr struct */
 		ethh = (struct ethhdr *)(page_address(skb_frags[0].page) +
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 					 skb_frags[0].offset);
+#else
+					 skb_frags[0].page_offset);
+#endif
 		s_mac = mlx4_en_mac_to_u64(ethh->h_source);
 
 		/* If source MAC is equal to our own MAC and not performing
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
index 019d856..5a2bddd 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
@@ -529,7 +529,11 @@ u16 mlx4_en_select_queue(struct net_device *dev, struct sk_buff *skb)
 	u16 rings_p_up = priv->mdev->profile.num_tx_rings_p_up;
 	u8 up = 0;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	if (dev->num_tc)
+#else
+	if (netdev_get_num_tc(dev))
+#endif
 		return skb_tx_hash(dev, skb);
 
 	if (vlan_tx_tag_present(skb))
-- 
1.7.0.4

